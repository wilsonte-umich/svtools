
# get passed arguments
sample          <- Sys.getenv("sample")
pdfDir          <- Sys.getenv("pdfDir")
tLenFile        <- Sys.getenv("tLenFile")
maxCnvSize      <- as.numeric(Sys.getenv("maxCnvSize"))
min_scan_pairs  <- as.numeric(Sys.getenv("min_scan_pairs"))
min_neg_pairs   <- as.numeric(Sys.getenv("min_neg_pairs"))

# calculate derived values
minTLen  <- -maxCnvSize;
maxTLen  <- 2 * maxCnvSize;

# get the expected TLEN frequency distributions
#   generated by svtools pdf for the same libraries/sample
write("  loading library TLEN distributions", file=stderr())
distFile      <- paste(pdfDir, "/svtools.pdf.", sample, ".all.gz", sep="")
dist          <- read.table(distFile, header=FALSE, sep="\t", stringsAsFactors=FALSE)
colnames(dist)<- c('tLen', 'freq')
dist          <- dist[dist$tLen>=minTLen&dist$tLen<=maxTLen,]
tLens         <- dist$tLen

# calculate weighted frequency for crossing fragments of TLEN based on CNV size
#   dist has size frequency by fragment _count_
#   need to weight by abs(TLEN) to get the probablity that 
#   a given position will cross a mapped span of a given length
weightFreqs <- function(freq, tLen){
    wF <- freq * abs(tLen)
    wF / sum(wF)
}

# establish pdf and cdf functions for expected/reference pairs
write("  constructing expected pdf and cdf functions", file=stderr())
wF          <- weightFreqs(dist$freq, tLens)
pdf_ref     <- stepfun(tLens, c(0, wF))
cdf_ref     <- stepfun(tLens, c(0, cumsum(wF)))
cdf_ref_val <- cdf_ref(tLens)

# analyze each bin, i.e. each discrete genome position
#   report results as isGap, n_log_p, deltaCDF_abs, deltaCDF_sgn
parse_bin <- function(bin){
    res <- if(bin[1] < min_scan_pairs){
        c(1, 0, 0, 0)
    } else {
        tL   <- as.numeric(strsplit(bin[2], ",")[[1]])
        nNeg <- length(tL[tL<=0])
        if(nNeg > 0 & nNeg < min_neg_pairs){ # ignore rare spurious dup pairs
            tL <- tL[tL>0]
        }
        if(length(tL) < min_scan_pairs){
            c(1, 0, 0, 0)
        } else {
            cdf_act_val <- ecdf(tL)(tLens)              
            c(0,
              round(min(15, -log10(suppressWarnings(ks.test(tL, cdf_ref)$p.value))), 3),
              round(sum(abs(cdf_act_val - cdf_ref_val)), 2),
              round(sum(    cdf_act_val - cdf_ref_val) , 2)
            )            
        }
    }
    paste(res, collapse="\t")
}

# get the TLEN data for all interrogated bin positions
write("  loading bin TLEN data", file=stderr())
bins <- read.table(tLenFile, header=FALSE, sep="\t", stringsAsFactors=FALSE)
colnames(bins) <- c('chrom', 'binI', 'nFrags', 'fracLowQual', 'tLens', 'output')

# do the scan and return the results
write("  calculating bin deviations", file=stderr())
for (chrom in unique(bins$chrom)) {
    write(paste("    ", chrom, sep=""), file=stderr())
    is <- which(bins$chrom==chrom)
    bins[is,6] <- apply(bins[is,c(3,5)], 1, parse_bin)
}
write.table(
    bins,
    file      = "",
    quote     = FALSE,
    sep       = "\t",
    row.names = FALSE,
    col.names = FALSE
) 

